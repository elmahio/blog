# ASP.NET Core Logging Tutorial##### [Thomas Ardal](http://elmah.io/about/), November ?, 2016Most parts of elmah.io consist of small services. While they may not be microservices, they are in fact small and each do one thing. We recently started experimenting with ASP.NET Core (or just Core for short) for some internal services and are planning a number of blog posts about the experiences we have made while developing these services. This is the fourth part in the series. The previous posts are: [AppSettings in ASP.NET Core](appsettings-in-aspnetcore.md), [Config transformations in ASP.NET Core](config-transformations-in-aspnetcore.md) and [Configuration with Azure App Services and ASP.NET Core](configuration-with-azure-app-services-and-aspnetcore.md).In the previous posts, focus was all around configuration. In this post, we will take a look at the new logging features in ASP.NET Core. Where previous versions of ASP.NET had hooks to capture information about exceptions and similar, ASP.NET Core comes with its own logging framework called Microsoft.Extensions.Logging. Microsoft.Extensions.Logging is available on NuGet and isn't bound to ASP.NET Core in any way. This mean that you will be able to utilize this new logging from Microsoft throughout all of your applications and services if you want. Logging is based on providers known from similar frameworks like appenders in log4net and sinks in Serilog. A range of providers are available on NuGet for most existing logging frameworks like NLog, Serilog and elmah.io. In other words, you don't need to switch to another logging framework, since you can always configure your favourite provider for a another logging framework of your choice.Let's learn about Microsoft.Extensions.Logging from an example. Create a new ASP.NET Core project through Visual Studio or the command line. In my case, I'm using Visual Studio 2017 RC, but the generated code looks the same when generated from VS2015 or the CLI. When generated, open the `Startup.cs` file and navigate to the `Configure` method:```csharp// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory){    loggerFactory.AddConsole(Configuration.GetSection("Logging"));    loggerFactory.AddDebug();    if (env.IsDevelopment())    {        app.UseDeveloperExceptionPage();        app.UseBrowserLink();    }    else    {        app.UseExceptionHandler("/Home/Error");    }    app.UseStaticFiles();    app.UseMvc(routes =>    {        routes.MapRoute(            name: "default",            template: "{controller=Home}/{action=Index}/{id?}");    });}```As stated in the comment in the top, the `Configure` method is called when starting the website. See the `ILoggerFactory` parameter sent to the method? That's our main entry point for configuring logging. `ILoggerFactory` provides a fluent API for setting up our logging needs. To do some logging, we need an instance of another interface called `ILogger`, but let's with that for a minute.The code is pretty much self-documented. We tell Microsoft.Extensions.Logging to log messages to the console and debug (through `System.Diagnostics.Debug.WriteLine`). In a future post, I'll show you how to configure different aspects of logging. For now, the only thing I'll mention is log levels. Like Serilog, NLog etc., Microsoft.Extensions.Logging implements a range of different log levels from Trace to Critical. As default, most providers only logs from Information and up. If you want to extend this to also log Trace and Debug messages, you can configure this as part of adding each provider:```csharploggerFactory.AddDebug(LogLevel.Trace);```The console provider configured as part of the generated code, actually uses the `appsettings.json` file as explained in the previous three posts. To change the minimum log level for this log level, either configure the provider all through C# code or change the `Logging.LogLevel.Default` setting in `appsettings.json`:```json{  "Logging": {    "IncludeScopes": false,    "LogLevel": {      "Default": "Trace",      "System": "Information",      "Microsoft": "Information"    }  }}```Until now, we've never actually logged anything. To do so, use dependency injection in ASP.NET Core to inject either an instance of `ILoggerFactory` in your controller:```chsarppublic class HomeController : Controller{    ILoggerFactory _loggerFactory;    public HomeController(ILoggerFactory loggerFactory)    {        _loggerFactory = loggerFactory;    }    public IActionResult Index()    {        var logger = _loggerFactory.CreateLogger("MyLogger");        logger.LogInformation("Calling the Index action");        return View();    }}```I've injected the `ILoggerFactory` into the `HomeController`. To start logging, call the `CreateLogger` method to get an instance of an `ILogger`. As previously mentioned, the `ILogger` is the client actually used to log messages to the configured providers. In this example, I log an information message. The `MyLogger` string sent to the `CreateLogger` method, tells Microsoft.Extensions.Logging that all messages logged to this logger, will be in the `MyLogger` category. Categories is something that I want to elaborate on in a future post.Instead of creating a new logger every time, we can simply inject an instance of `ILogger` instead:```chsarppublic class HomeController : Controller{    ILogger<HomeController> _logger;    public HomeController(ILogger<HomeController> logger)    {        _logger = logger;    }    public IActionResult Index()    {        _logger.LogInformation("Calling the Index action");        return View();    }}```Notice how I now inject an `ILogger` instance, rather than an `ILoggerFactory`. Decorating the `ILogger` with a generic parameter of `HomeController`, automatically generates a logger with a category of the `HomeController`.